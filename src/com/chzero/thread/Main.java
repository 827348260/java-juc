package com.chzero.thread;

/**
 * @author CHZERO
 * @version 1.0
 * @date 2018-06-30 17:33
 * @email 827348260@qq.com
 * @description
 * 1. 通过继承java.lang.Thread类实现多线程 重写run()方法, 通过start()方法启动线程
 * 2. 通过实现java.lang.Runnable接口并重写run()方法; 将实现类传给Thread实例调用start()方法启动线程;
 *
 * 避免了单继承的局限性
 * 多个线程可以共享同一个接口实现类的对象，非常适合多个相同线程来处理同一份资源
 *
 * 新建, 就绪, 运行, 阻塞, 死亡
 *
 * (synchronized(同步监视器){}) 同步代码块: 1. 共享数据:多个线程共同操作的数据.
 *                                        2. 同步监视器: 任何对象充当(所有线程共用同一个锁[this]), 哪个线程获得了此监视器, 谁就能指定{}中的代码, 俗称: 锁
 *                                        3. 注意: 在实现的方式中可以使用this来充当锁, 在继承的方式中, 慎用this当锁;
 * (synchronized void method(){}) 同步方法: 1. 保证当有线程在执行此方法时, 其他线程必须等待此线程执行完此方法;
 *                                         2. 同步方法的锁: this
 * 对于静态方法而言, 同步代码块和同步方法使用当前类本身充当锁(Class.class);
 *
 * 同步方法（非静态的）的锁为this.
 * 同步方法（  静态的）的锁为当前类本身.
 *
 * 不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁
 */
public class Main{}
